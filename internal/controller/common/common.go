// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package common

import (
	"context"
	"fmt"
	"github.com/gogf/gf/v2/container/gvar"
	"github.com/gogf/gf/v2/crypto/gmd5"
	"github.com/gogf/gf/v2/errors/gcode"
	"github.com/gogf/gf/v2/errors/gerror"
	"github.com/gogf/gf/v2/frame/g"
	"github.com/gogf/gf/v2/os/gctx"
	"github.com/gogf/gf/v2/util/gconv"
	"github.com/gogf/gf/v2/util/gmode"
	"github.com/gogf/gf/v2/util/grand"
	v1 "gohub/api/common/v1"
	"gohub/internal/consts"
	"gohub/internal/model/entity"
	"gohub/internal/service"
	"gohub/utility/errUtils"
	"gohub/utility/utils"
	"time"
)

// 统一读取配置项
var (
	ctx            = gctx.New()
	cacheKeyPrefix = utils.GetConfig(ctx, "verifyCode.cacheKeyPrefix")
	expiredTime    = int64(utils.GetConfigInt(ctx, "verifyCode.expiredTime")) // seconds
	tmplFilePath   = "resource/template/email.html"
	multiLogin     = utils.GetConfigBool(ctx, "sSysLoginLog.multiLogin")
)

// 生成验证码
func genVerifyCode() string {
	return grand.Digits(6)
}

// 验证码保存到redis中
func cacheVerifyCode(key, verifyCode string) {
	cacheKey := fmt.Sprintf("%s%s", cacheKeyPrefix, key)
	err := service.Cache().GetCache().Set(ctx, cacheKey, verifyCode, time.Duration(expiredTime)*time.Second)
	errUtils.ErrIfNotNil(ctx, err, consts.InternalServerError)
}

// 判断验证码是否正确
func verifyCaptcha(verifyKey, verifyCode string) {
	err := service.Captcha().VerifyCaptcha(verifyKey, verifyCode)

	errUtils.ErrIfNotNil(ctx, err)
}

// checkVerifyCode 判断验证码是否正确
func checkVerifyCode(ctx context.Context, key, code string) (err error) {
	cache := service.Cache().GetCache()
	var verifyCode *gvar.Var
	cacheKey := fmt.Sprintf("%s%s", cacheKeyPrefix, key)
	verifyCode, err = cache.Get(ctx, cacheKey)
	errUtils.ErrIfNotNil(ctx, err, consts.InternalServerError)
	if verifyCode == nil {
		err = gerror.NewCode(gcode.CodeInvalidParameter, "验证码已过期")
		return
	}
	if verifyCode.String() != code {
		err = gerror.NewCode(gcode.CodeInvalidParameter, "验证码输入错误")
		return
	}
	// 删除已验证的验证码
	_, err = cache.Remove(ctx, cacheKey)
	errUtils.ErrIfNotNil(ctx, err, consts.InternalServerError)
	return
}

// LoginCommon 统一登陆操作
func LoginCommon(ctx context.Context, key, verifyKey, verifyCode, loginType string) (err error, loginRes *v1.LoginResCommon) {
	var (
		user  *entity.SysUser
		token string
	)
	//判断验证码是否正确
	if gmode.IsDevelop() {
		// 开发环境不需要验证码
	} else if loginType == "user" {
		// 账号密码登陆使用图形验证码
		verifyCaptcha(verifyKey, verifyCode)
	} else {
		// 否则使用邮箱/手机验证码
		err = checkVerifyCode(ctx, key, verifyCode)
		if err != nil {
			return
		}
	}
	ip := utils.GetClientIp(ctx)
	userAgent := utils.GetUserAgent(ctx)
	user, err = service.SysUser().GetUserByUniqueKey(ctx, key)
	if err != nil {
		// 保存登录失败的日志信息
		service.SysLoginLog().Invoke(ctx, key, loginType, err.Error(), 1)
		return
	}
	err = service.SysUser().UpdateLoginInfo(ctx, user.Id, ip)
	if err != nil {
		return
	}
	// 保存登录成功的日志信息
	service.SysLoginLog().Invoke(context.WithoutCancel(ctx), key, loginType, "登陆成功", 0)
	tokenKey := gconv.String(user.Id) + "-" + gmd5.MustEncryptString(user.UserName) + gmd5.MustEncryptString(user.UserPassword)
	if multiLogin {
		tokenKey = gconv.String(user.Id) + "-" + gmd5.MustEncryptString(user.UserName) + gmd5.MustEncryptString(user.UserPassword+ip+userAgent)
	}
	user.UserPassword = ""
	token, err = service.GhToken().GenerateToken(ctx, tokenKey, user)
	if err != nil {
		g.Log().Error(ctx, err)
		err = gerror.New("登录失败，后端服务出现错误")
		return
	}
	//获取用户数据
	loginRes = &v1.LoginResCommon{
		UserInfo: user,
		Token:    token,
	}
	return
}
